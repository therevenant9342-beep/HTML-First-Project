<!DOCTYPE html>
<html lang="ar" dir="rtl">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>محاكاة نقطة الركود - Stagnation Point</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Tajawal:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Tajawal', sans-serif;
            background-color: #f0f9ff;
        }

        canvas {
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            cursor: crosshair;
        }

        .highlight-text {
            color: #dc2626;
            font-weight: bold;
        }
    </style>
</head>

<body class="bg-slate-50 min-h-screen flex flex-col items-center py-8 px-4">

    <!-- Header -->
    <header class="text-center mb-8 max-w-2xl">
        <h1 class="text-3xl font-bold text-slate-800 mb-2">نقطة الركود (Stagnation Point)</h1>
        <p class="text-slate-600 text-lg">
            شاهد كيف يتصرف المائع عند الاصطدام بمقدمة الأنبوب (أو أي جسم صلب).
        </p>
    </header>

    <!-- Main Content Grid -->
    <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 max-w-6xl w-full">

        <!-- Simulation Panel -->
        <div class="bg-white p-4 rounded-xl shadow-lg flex flex-col items-center justify-center relative">
            <div
                class="absolute top-4 right-4 bg-blue-100 text-blue-800 px-3 py-1 rounded-full text-sm font-semibold z-10">
                سرعة التدفق: <span id="speedValue">Normal</span>
            </div>

            <canvas id="flowCanvas" width="600" height="400" class="bg-slate-900 w-full h-auto max-w-[600px]"></canvas>

            <div class="mt-4 flex gap-4 w-full justify-center">
                <button onclick="window.toggleParticles()"
                    class="bg-blue-600 hover:bg-blue-700 text-white px-6 py-2 rounded-lg transition">
                    تشغيل / إيقاف الجزيئات
                </button>
                <button onclick="window.toggleStreamlines()"
                    class="bg-slate-600 hover:bg-slate-700 text-white px-6 py-2 rounded-lg transition">
                    إظهار / إخفاء خطوط الانسياب
                </button>
            </div>
            <p class="mt-2 text-sm text-slate-500">حرك الفأرة (أو المس) داخل الرسم لرؤية قيم السرعة والضغط.</p>
        </div>

        <!-- Explanation Panel -->
        <div class="bg-white p-6 rounded-xl shadow-lg space-y-6">

            <div class="border-r-4 border-red-500 pr-4">
                <h2 class="text-xl font-bold text-slate-800 mb-2">ما هي النقطة الحمراء؟</h2>
                <p class="text-slate-700 leading-relaxed">
                    النقطة الحمراء المتوهجة في مقدمة الأسطوانة هي <span class="highlight-text">نقطة الركود</span>.
                    هنا يصطدم المائع مباشرة بالجسم. الجزيئات الموجودة على هذا الخط بالضبط لا يمكنها الذهاب لليمين ولا
                    لليسار، فتتوقف تماماً.
                </p>
            </div>

            <div class="bg-blue-50 p-4 rounded-lg">
                <h3 class="font-bold text-blue-900 mb-2">المعادلة الفيزيائية (برنولي):</h3>
                <p class="text-blue-800 text-lg font-mono text-left" dir="ltr">
                    P + ½ρv² = Constant
                </p>
                <ul class="list-disc list-inside mt-2 text-slate-700 space-y-1">
                    <li>عند نقطة الاصطدام، السرعة <strong>(v) تصبح صفراً</strong>.</li>
                    <li>بالتالي، الطاقة الحركية تتحول بالكامل إلى <strong>ضغط</strong>.</li>
                    <li>لذلك، الضغط عند هذه النقطة هو <strong>الأعلى</strong> على الإطلاق.</li>
                </ul>
            </div>

            <div>
                <h3 class="font-bold text-slate-800 mb-2">لماذا هذا مهم؟</h3>
                <p class="text-slate-600 text-sm leading-relaxed">
                    نستخدم هذه الظاهرة في الطائرات عبر جهاز يسمى <strong>"أنبوب بيتوت" (Pitot Tube)</strong>. نقيس الضغط
                    العالي عند نقطة الاصطدام، ونقارنه بالضغط الجوي العادي، ومن الفرق بينهما نستطيع حساب سرعة الطائرة
                    بدقة.
                </p>
            </div>

            <!-- Stats Display -->
            <div id="statsBox" class="hidden bg-slate-800 text-green-400 p-3 rounded font-mono text-sm text-left"
                dir="ltr">
                Cursor Probe:<br>
                Velocity (v): <span id="vVal">0.0</span> m/s<br>
                Pressure Coeff (Cp): <span id="pVal">0.0</span>
            </div>

        </div>
    </div>

    <script>
        // Wrap logic in an IIFE to prevent global scope pollution and redeclaration errors
        (function() {
            const canvas = document.getElementById('flowCanvas');
            const ctx = canvas.getContext('2d');
            const statsBox = document.getElementById('statsBox');
            const vVal = document.getElementById('vVal');
            const pVal = document.getElementById('pVal');

            // Simulation Parameters
            const cylinderX = canvas.width / 2;
            const cylinderY = canvas.height / 2;
            const radius = 60; // Radius of the pipe/cylinder
            const U = 2; // Free stream velocity
            
            // State variables (scoped locally)
            let showParticles = true;
            let showStreamlines = true;
            let animationId;

            // Make toggle functions available globally for HTML buttons
            window.toggleParticles = function() {
                showParticles = !showParticles;
            };

            window.toggleStreamlines = function() {
                showStreamlines = !showStreamlines;
            };

            // Particle System
            const particles = [];
            const numParticles = 400;

            class Particle {
                constructor() {
                    this.reset();
                }

                reset() {
                    this.x = Math.random() * canvas.width;
                    this.y = Math.random() * canvas.height;
                    this.age = Math.random() * 100;
                    this.speedMult = 0.8 + Math.random() * 0.4;
                }

                resetLeft() {
                    this.x = 0;
                    this.y = Math.random() * canvas.height;
                    this.age = 0;
                }

                update() {
                    const dx = this.x - cylinderX;
                    const dy = this.y - cylinderY;
                    const r2 = dx*dx + dy*dy;
                    const r = Math.sqrt(r2);
                    
                    if (r < radius) {
                        this.vx = 0;
                        this.vy = 0;
                    } else {
                        const phi = Math.atan2(dy, dx);
                        const R2_r2 = (radius * radius) / r2;
                        
                        // Velocity field for flow around cylinder
                        const vx = U * (1 - R2_r2 * Math.cos(2 * phi));
                        const vy = U * (-R2_r2 * Math.sin(2 * phi));
                        
                        this.vx = vx;
                        this.vy = vy;
                    }

                    this.x += this.vx * 3 * this.speedMult;
                    this.y += this.vy * 3 * this.speedMult;

                    // Reset if goes off screen
                    if (this.x > canvas.width || this.x < 0 || this.y > canvas.height || this.y < 0) {
                        this.resetLeft();
                    }
                    
                    // Reset if somehow inside cylinder
                    if (dx*dx + dy*dy < radius*radius * 0.9) {
                         if (Math.abs(dy) < 5 && dx < 0) {
                             // Let it stay briefly to show stagnation
                         } else {
                             this.resetLeft();
                         }
                    }
                }

                draw() {
                    const speed = Math.sqrt(this.vx*this.vx + this.vy*this.vy);
                    
                    let r, g, b;
                    if (speed < 0.3) {
                        r = 255; g = 50; b = 50; 
                    } else {
                        r = 100; g = 200; b = 255; 
                    }

                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.8)`;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Initialize particles
            for (let i = 0; i < numParticles; i++) {
                particles.push(new Particle());
            }

            function drawCylinder() {
                ctx.beginPath();
                ctx.arc(cylinderX, cylinderY, radius, 0, Math.PI * 2);
                ctx.fillStyle = '#cbd5e1'; 
                ctx.fill();
                ctx.strokeStyle = '#334155';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw Stagnation Point Marker
                ctx.beginPath();
                ctx.arc(cylinderX - radius, cylinderY, 6, 0, Math.PI * 2);
                ctx.fillStyle = '#ef4444'; // Bright Red
                ctx.fill();
                ctx.shadowBlur = 10;
                ctx.shadowColor = "red";
                ctx.fill();
                ctx.shadowBlur = 0;
                
                // Label
                ctx.fillStyle = '#f8fafc';
                ctx.font = '14px Tajawal';
                ctx.fillText("نقطة الاصطدام (V=0)", cylinderX - radius - 110, cylinderY + 5);
            }

            function drawStreamlines() {
                if (!showStreamlines) return;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 1;
                
                const startY = [cylinderY, cylinderY - 10, cylinderY + 10, cylinderY - 30, cylinderY + 30, cylinderY - 60, cylinderY + 60, cylinderY - 90, cylinderY + 90];
                
                for (let yStart of startY) {
                    let px = 0;
                    let py = yStart;
                    ctx.beginPath();
                    ctx.moveTo(px, py);
                    
                    for (let i = 0; i < canvas.width; i+=5) {
                        const dx = px - cylinderX;
                        const dy = py - cylinderY;
                        const r2 = dx*dx + dy*dy;
                        
                        const phi = Math.atan2(dy, dx);
                        const R2_r2 = (radius * radius) / r2;
                        
                        const vx = U * (1 - R2_r2 * Math.cos(2 * phi));
                        const vy = U * (-R2_r2 * Math.sin(2 * phi));
                        
                        const v = Math.sqrt(vx*vx + vy*vy);
                        if (v > 0.01) {
                            px += (vx/v) * 5;
                            py += (vy/v) * 5;
                            ctx.lineTo(px, py);
                        }
                    }
                    ctx.stroke();
                }
            }

            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                drawStreamlines();

                if (showParticles) {
                    particles.forEach(p => {
                        p.update();
                        p.draw();
                    });
                }

                drawCylinder();
                animationId = requestAnimationFrame(animate);
            }

            // Mouse Interaction
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const dx = mouseX - cylinderX;
                const dy = mouseY - cylinderY;
                const r2 = dx*dx + dy*dy;
                const r = Math.sqrt(r2);

                let v = U;
                let cp = 0;

                if (r >= radius) {
                    const phi = Math.atan2(dy, dx);
                    const R2_r2 = (radius * radius) / r2;
                    const vx = U * (1 - R2_r2 * Math.cos(2 * phi));
                    const vy = U * (-R2_r2 * Math.sin(2 * phi));
                    v = Math.sqrt(vx*vx + vy*vy);
                    
                    cp = 1 - (v/U)*(v/U);
                } else {
                    v = 0;
                    cp = 1; 
                }
                
                statsBox.classList.remove('hidden');
                statsBox.style.display = 'block';
                vVal.textContent = v.toFixed(2);
                pVal.textContent = cp.toFixed(2);
                
                if (r < radius + 10 && r > radius - 10 && dx < 0 && Math.abs(dy) < 10) {
                     vVal.textContent = "0.00 (STAGNATION)";
                     vVal.style.color = "red";
                     pVal.textContent = "1.00 (MAX)";
                     pVal.style.color = "red";
                } else {
                     vVal.style.color = "";
                     pVal.style.color = "";
                }
            });

            canvas.addEventListener('mouseleave', () => {
                statsBox.classList.add('hidden');
            });

            // Start animation
            if (window.currentAnimationId) {
                cancelAnimationFrame(window.currentAnimationId);
            }
            animate();
            window.currentAnimationId = animationId;

        })();
    </script>
</body>

</html>